# Geospatial


```{r}
library(sf)
library(ggplot2)
library(rnaturalearth)
library(rnaturalearthdata)
library(tidyr)
library(dplyr)
# remote::install_github("ropensci/rnaturalearthhires")

```



## Geodata

- [UCR STAR](https://star.cs.ucr.edu/about.html)
- <https://wiki.openstreetmap.org/wiki/Planet.gpx#Visualisation>

## Misc


### Degrees to Meters (e.g. for raster resolution)

When dealing with Geographic Coordinates (e.g. Lat / Lon), it's helpful to convert the units to meters to get a feel for the real world distances you are dealing with. Assuming the Earth is a sphere with a circumference of 40'075 km:

- 1° of latitude distance (i.e. distance in the y direction, towards a pole) is always 111.32 km
  - A raster resolution of 0.1666667 has a cell height of ~18.5 km (`111.32 * 0.1666667`)
- 1° of longitude distance (i.e. distance in the x direction, parallel to the equator) varies, depending on the latitude the following function ([from here](https://stackoverflow.com/a/39540339/4139249)) approximates it: 

$$\text{Length in km of 1° of longitude} = 40075* cos( \text{latitude} ) / 360$$

The functions expects latitude in degrees. The `cos` function in R expects it in Rad. Implemented in R, the function above is:

```{r}
length_1deg_longitude <- \(latitude) 40075 * cos(latitude / 180 * 3.14159) / 360
```



  - Lat 0 (equator): 111.3km
  - Lat 45: 78 km
  - Lat 80: 19 km
  - Lat 90: 0 km
- Resolutions are often discribed in degrees, minutes and seconds. To convert these into decimal degrees: $$\text{degrees}_\text{decimal} = \text{degrees}+ \frac{\text{minutes}}{60} + \frac{\text{seconds}}{3600}$$ 
   - 30 arcseconds: 0.00833333 decimal degrees
   - 1 arcminute: 0.01677777 decimal degrees
   - 10 arcminutes: 0.16777777 decimal degrees
   - 1 degree: 1 decimal degrees



The [haverstine distance function](https://stackoverflow.com/a/28372037/4139249) gives a good approximation of the distance in meters.

```{r}
haverstine_distance <- function(
  lon1,
  lat1,
  lon2 = lon1+1, # default: 1 degree in the x-direction
  lat2 = lat1    # default: 0 degrees in the y-direction
  ) {
    R <- 6378.137                                # radius of earth in Km
    dLat <- (lat2-lat1)*pi/180
    dLon <- (lon2-lon1)*pi/180
    a <- sin((dLat/2))^2 + cos(lat1*pi/180)*cos(lat2*pi/180)*(sin(dLon/2))^2
    c <- 2 * atan2(sqrt(a), sqrt(1-a))
    d <- R * c
    return (d * 1000)                            # distance in meters
}
``` 

To convert a raster resolution of 0.166666 to meters with the above function, simply do:

```{r}
haverstine_distance(0, 45)*0.1666666 # at 45 latitude
```


### A (non sensical) experiment:

Visualize the horizontal and the vertical distance at each degree on the globe:

```{r}
dist_in_deg = 1 # change to 0.166666 for a raster resolution of this value
expand.grid(lat = seq(-90, 90, 1), lon = seq(-180, 180, 1)) |>
mutate(
    hdist = haverstine_distance(lon, lat, lon+dist_in_deg, lat),
    vdist = haverstine_distance(lon, lat, lon, lat+dist_in_deg)
    ) |>
pivot_longer(ends_with("dist")) |>
ggplot(aes(lon, lat, fill = value)) +
geom_raster() +
scale_fill_viridis_c() +
facet_wrap(~name)
```


### A second experiment

Horizontal Distance at each latitude for different raster resolutions

```{r}
expand.grid(lat = seq(-90, 90, 1), res = c(1, 0.16666666, 0.008333333)) |>
mutate(
    hdist = haverstine_distance(0, lat)*res
) |>
ggplot(aes(hdist, lat)) +
geom_point() +
facet_wrap(~res, scales = "free_x")
```


## CRS, Projections, Datums

### A working model

Coordinates are just numbers assigned to data. To interprete them, you need to know the Coordinate Reference System (CRS) they are stored in. For spatial data types (geopackage, shapefile, geotiff etc) the CRS is stored in the files metadata. For non spatial data types (e.g. a csv), this information must be stored in a different way. CRS Information can be referenced to with `Authority: Code`, whereas the most used authority is the European Petrolium Survey Group (EPSG). 

To visualize spatial data in 2D (on a screen or on paper), it differs whether the CRS is a *projected* or a *geographic* CRS . If its the former, then the coordinates can be used in a  Cartesian plane (classic x/y scatter plot type). If its the latter, then it needs to be *projected* into 2D first. In GIS that focus on visualizing the data constantly, e.g. **in ArcGIS or QGIS, this information is stored in the project file**. In R or Python, this information must be provided onto the plotting library when visualizing the data explicitly. 

Confusingly, the methods of projecting geographic coordinates into 2D is referenced to with the same EPSG Codes as the CRS. So what happens when you have a geographic coordinate system (e.g. WGS84) and you "reproject" it to 2d using EPSG 4326? I'm not sure, but if [this SO answer](https://gis.stackexchange.com/a/387518/40929) is correct, it might shed some light on the question:

> EPSG 4326 (i.e. WGS 84) is not a projection. But if you don't associate a projection to this geographic coordinate system, and naively render the coordinates as x/y coordinates on a grid, you do get something that is sort of a projection: the pseudo plate carée (equirectangular) projection. (This is not the same as an actual plate carée projection with a WGS 84 GCS, as this would have units in metres, not degrees). 


This is all good, but I have trouble understanding [this](https://www.isric.org/explore/soilgrids/faq-soilgrids#How_can_I_access_SoilGrids):

> To deal with an increasing number of inputs and computation demands, SoilGrids has since 2019 been computed on an equal-area projection. After a thorough comparison, the Homolosine projection was identified as the most efficient in an open source software framework.
> 
> The Homolosine projection is not mandatory in any way. The WMS and WCS publish the SoilGrids maps in the following alternative SRSs:
> 
> - EPSG:4326 - the popular Marinus of Tyre projection (aka Plate Carré) applied on the WGS84 datum. **It expands the surface area of the globe by 60%.**


### S2 library

You need to be careful with geographic CRS when calculating distances, areas or angles, or doing other spatial operations. For example in R (`sf`), until June 2020, if you a spatial operation on data with a geographic CRS, "*you are carrying out an operation that assumes these data lie in a flat plane, where one degree longitude equals one degree latitude, irrespective where you are on the world. This means that your data are assumed implicitly to be projected to the equirectangular projection*" (see [here](https://r-spatial.org/r/2020/06/17/s2.html)). As of version 1.0, `sf` uses googles `s2` library for spatial operations on geographic data. S2 is based on a spherical world: "*Although we know that an ellipsoid better approximates the Earths’ shape, computations done with s2 are all on a spere. The difference between ellipsoidal and spherical computations is roughly up to 0.5%*". For areas (in North Carolina or globaly?) it is $6.4 \times 10^{-5}$. 

More from [this article](https://r-spatial.org/r/2020/06/17/s2.html)

> As an example, consider the polygon from POLYGON((-150 -65, 0 -62, 120 -78, -150 -65)), drawn as a line in this projection 
>
> ![image](https://user-images.githubusercontent.com/12532091/227450732-a67393a9-476b-459e-8308-f2db6db25054.png)
>
> S2 geometry assumes that straight lines between points on the globe are not formed by straight lines in the equirectangular projection, but by great circles: the shortest path over the sphere. For the polygon above this would give:
> ![image](https://user-images.githubusercontent.com/12532091/227450938-066c9f53-c7ae-4a3f-b04d-d199f1450bd4.png)
> 
> where the light green polygon is the “straight line polygon” in equirectangular. Based on the great circle lines, this polygon now contains the South Pole:


### An experiment

To get my head around projections, I did a little experiment in R for the Remote Sensing class. Here's the uncommented, untidy code... todo: tidy this up, comment it and paste the resulting plots!

```{r}
world_countries <- rnaturalearth::ne_countries(returnclass = "sf")
switzerland <- ne_countries(scale = 10, country = "switzerland", returnclass = "sf")




ullr2poly <- function(xmin, ymin, xmax, ymax){
  c(1,2,1,4,3,4,3,2,1,2) |>
    sapply(\(x)c(xmin, ymin, xmax, ymax)[x]) |>
    matrix(ncol = 2, byrow = TRUE) |>
    list() |>
    st_polygon()
}

world_box <- ullr2poly(xmin = -180, ymin = -90, xmax = 180, ymax = 90) %>% 
  st_sfc() %>% 
  st_set_crs(4326) 


x <- seq(-180, 180,20)
y <- seq(-90, 90, 20)

length(x) * length(y)
my_points  <- expand.grid(x = x, y = y) %>%
  st_as_sf(coords = c("x","y"), remove = FALSE, crs = 4326)

my_circles <- my_points %>% 
  st_buffer(500e3)

my_circles_filter <- dplyr::filter(my_circles, abs(x) != 180)
  
st_area(my_circles_filter) %>% as.numeric() %>% (\(x) ((x/pi)^0.5)/1e3) 

mymap <- ggplot() +
  geom_sf(data = world_countries, fill = "darkgrey",color = "lightgrey") +
  # geom_sf(data = my_circles, alpha = 0.3) +
  scale_x_continuous(breaks = x) + 
  scale_y_continuous(breaks = y) +
  theme(panel.background = element_blank(), panel.grid = element_line("orange", linetype = 2),panel.ontop = TRUE) 

mymap
mymap2 <- mymap + 
  geom_sf(data = my_points) +
  geom_sf(data = my_circles_filter, alpha = 0.3)


lat <- 45
lon <- 2
ortho <- paste0('+proj=ortho +lat_0=', lat, ' +lon_0=', lon, ' +x_0=0 +y_0=0 +a=6371000 +b=6371000 +units=m +no_defs')
circle <- st_point(x = c(0,0)) %>% st_buffer(dist = 6371000) %>% st_sfc(crs = ortho)
# https://gist.github.com/fzenoni/ef23faf6d1ada5e4a91c9ef23b0ba2c1?permalink_comment_id=3106327

mymap + 
  geom_sf(data = circle, fill = NA) +
  coord_sf(crs = ortho) +
  theme(panel.background = element_rect(fill="transparent"),
        plot.background = element_rect(fill="transparent", color=NA),
        panel.ontop = FALSE)


mymap2 + 
  geom_sf(data = circle, fill = NA) +
  coord_sf(crs = ortho) + 
  # labs(title = stringr::str_to_title(proji)) +
  theme()




mymap + coord_sf(crs = "+proj=laea +lon_0=8 +lat_0=46 +ellps=WGS84 +no_defs")

mymap + geom_sf(data = my_circles, alpha = 0.3)+ coord_sf(crs = "+proj=laea +lon_0=8 +lat_0=46 +ellps=WGS84 +no_defs")


mymap + geom_sf(data = my_circles, alpha = 0.3)+ coord_sf(crs = "+proj=laea +lat_0=53 +lon_0=9 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")

mymap + coord_sf(crs = "+proj=moll")
mymap + coord_sf(crs = "+proj=aeqd")

mymap + geom_sf(data = my_circles, alpha = 0.3)+ coord_sf(crs = "+proj=moll")

# does not seem to work. see https://stackoverflow.com/questions/71038065/accessing-equal-earth-projection-with-sf
mymap + coord_sf(crs = "+proj=eqearth +datum=WGS84 +wktext")
mymap + geom_sf(data = my_circles_filter, alpha = 0.3) + coord_sf(crs = "+proj=eqearth +datum=WGS84 +wktext")


```

```{r}
#| eval: false


# Write the created files to disk for later use
write_sf(my_circles_filter, "toy_data.gpkg","my_circles_filter")
write_sf(world_countries, "natural_earth.gpkg", "world")
write_sf(switzerland, "natural_earth.gpkg", "switzerland")

```



```{r}
#| eval: false

# iterate over all projections, and plot it,
# which takes a long time

projinfo <- sf_proj_info("proj")


plot_proj <- function(proji, desc, plot_it = TRUE){
  mymap2 + 
    coord_sf(crs = glue::glue("+proj={proji}")) + 
    labs(title = stringr::str_to_title(proji),caption = desc)
  
  if(plot_it)ggsave(file.path("projinfo_plots",glue::glue("{proji}.png")),scale = 2)
}


purrr::map2(projinfo$name, projinfo$description, \(proji, desc) tryCatch(plot_proj(proji, desc),error = function(e){e}))

```


```{r}
#| results: asis
#| echo: false
library(pander)

list.files("projinfo_plots/", full.names = TRUE) |> 
  pander::pandoc.image()
```

